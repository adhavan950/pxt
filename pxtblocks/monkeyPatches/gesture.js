"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.monkeyPatchGesture = void 0;
const Blockly = require("blockly");
function monkeyPatchGesture() {
    // This monkey patch is only required for the in-game experience of Minecraft on ChromeOS.
    // For some reason, events are occasionally dropped by the Android webview when multitouch
    // is being used which can cause Blockly to get stuck thinking it's in a gesture when it isn't.
    // This patch effectively removes multitouch by ignoring all pointer events except for ones
    // generated by the first pointer that is encountered. All pointerup events are still allowed
    // through (see wrapHandler below)
    if (!pxt.BrowserUtils.isAndroid() || !pxt.BrowserUtils.isInGame()) {
        return;
    }
    const oldDoStart = Blockly.Gesture.prototype.doStart;
    Blockly.Gesture.prototype.doStart = function (e) {
        if (this.id) {
            e.stopPropagation();
            e.preventDefault();
            return;
        }
        this.id = e.pointerId;
        oldDoStart.call(this, e);
    };
    Blockly.Gesture.prototype.bindMouseEvents = function (e) {
        if (!this.boundEvents_)
            this.boundEvents_ = [];
        const createSyntheticEvent = (e) => {
            const syntheticEvent = new PointerEvent(e.type, Object.assign(Object.assign({}, e), { clientX: e.clientX, clientY: e.clientY, pointerId: this.id }));
            syntheticEvent.stopPropagation = () => e.stopPropagation();
            syntheticEvent.stopImmediatePropagation = () => e.stopImmediatePropagation();
            syntheticEvent.preventDefault = () => e.preventDefault();
            return syntheticEvent;
        };
        const wrapHandler = (handler) => {
            return (e) => {
                // Always let pointerup events through, just remap them to the
                // correct pointerId. This lets us recover if we end up getting
                // stuck; the next click or drag on the workspace should clear the
                // current gesture.
                if (e.type === "pointerup") {
                    e = createSyntheticEvent(e);
                }
                else if (e.pointerId !== this.id) {
                    return;
                }
                try {
                    handler.call(this, e);
                }
                catch (e) {
                    pxt.error("Uncaught error while executing gesture handler", e);
                    this.cancel();
                    this.dispose();
                }
            };
        };
        this.boundEvents_.push(Blockly.browserEvents.conditionalBind(document, 'pointerdown', null, wrapHandler(this.handleStart), 
        /* opt_noCaptureIdentifier */ true));
        this.boundEvents_.push(Blockly.browserEvents.conditionalBind(document, 'pointermove', null, wrapHandler(this.handleMove), 
        /* opt_noCaptureIdentifier */ true));
        this.boundEvents_.push(Blockly.browserEvents.conditionalBind(document, 'pointerup', null, wrapHandler(this.handleUp), 
        /* opt_noCaptureIdentifier */ true));
        e.preventDefault();
        e.stopPropagation();
    };
    const oldDispose = Blockly.Gesture.prototype.dispose;
    Blockly.Gesture.prototype.dispose = function () {
        oldDispose.call(this);
        if (this.boundEvents_) {
            for (const event of this.boundEvents_) {
                Blockly.browserEvents.unbind(event);
            }
            this.boundEvents_.length = 0;
        }
    };
}
exports.monkeyPatchGesture = monkeyPatchGesture;
